cc main.c check_input.c parse_input.c push_swap.h utils_functions.c divide_stack.c swappers.c

// TESTING WITH VALGRIND

valgrind --leak-check=full ./a.out
valgrind -s --leak-check=full --show-leak-kinds=all ./test_push_swap 1 2 | cat -e

void sort_stack_five_numbers(t_stack **stack_a, t_stack **stack_b) {
    int min_position;

    if (*stack_a == NULL || (*stack_a)->len <= 3)
        return;

    while ((*stack_a)->len > 3) {
        min_position = find_min_node_position(*stack_a);
        if (min_position <= ((*stack_a)->len / 2)) {
            while (min_position--) {
                ra(stack_a);
            }
        } else {
            min_position = (*stack_a)->len - min_position;
            while (min_position--) {
                rra(stack_a);
            }
        }
        push_b(stack_a, stack_b);
    }

    sort_stack_three_numbers(stack_a);

    while (*stack_b) {
        push_a(stack_a, stack_b);
    }

    if ((*stack_a)->head->data > (*stack_a)->head->next->data) {
        sa(*stack_a);
    }
}

t_stack *handle_sort_options(t_stack **sa, t_stack **sb, int len_stack) {
    if (!sa || !*sa) {
        return NULL;
    }

    if (len_stack == 3) {
        sort_stack_three_numbers(sa);
    } else if (len_stack > 3) {
        sort_stack_five_numbers(sa, sb);
    }

    return *sa;
}

//fiveeee

void    handle_five(t_stack_node **a, t_stack_node **b)
{
    while (stack_len(*a) > 3)
    {
        t_stack_node *max_node = find_value_max(*a);
        if (*a == max_node)
        {
            ra(a);
            pb(a, b);
        }
        else if ((*a)->next == max_node)
        {
            rra(a);
            pb(a, b);
        }
        else
        {
            pb(a, b);
        }
    }
    // Ahora 'a' tiene 3 elementos que necesitan ser ordenados
    tiny_sort(a);
    // Mueve los elementos ordenados de 'a' de vuelta a 'b'
    while (*a)
    {
        pa(a, b);
    }
}
-----------------------------------=
void	sort_stack_five_numbers(t_stack **stack_a, t_stack **stack_b)
{
	int		max_node;
	int		i;
	t_node	*current;

	while ((*stack_a)->len > 3)
	{
		max_node = max_num_in_stack(*stack_a);
		current = (*stack_a)->head;
		i = 0;
		// Encuentra la posición del nodo con el valor máximo
		while (current != NULL)
		{
			if (current->data == max_node)
				break ;
			current = current->next;
			i++;
		}
		// Mueve el nodo con el valor máximo a stack_b
		if (i <= (*stack_a)->len / 2)
			while (i-- > 0)
				ra(stack_a);
		else
		{
			i = (*stack_a)->len - i;
			while (i-- > 0)
				rra(stack_a);
		}
		push_b(stack_a, stack_b);
	}
	// Ordena los tres nodos restantes en stack_a
	sort_stack_three_numbers(stack_a);
	// Mueve los nodos de vuelta de stack_b a stack_a
	while (*stack_b)
		push_a(stack_a, stack_b);
}

//////////////////////////////////
void handle_five(t_stack_node **a, t_stack_node **b)
{
    while (stack_len(*a) > 3)
    {
        t_stack_node *max_node = find_value_max(*a);
        if (*a == max_node)
        {
            ra(a);
            pb(a, b);
        }
        else if ((*a)->next == max_node)
        {
            rra(a);
            pb(a, b);
        }
        else
        {
            pb(a, b);
        }
    }
    // Ahora 'a' tiene 3 elementos que necesitan ser ordenados
    tiny_sort(a);
    // Mueve los elementos ordenados de 'a' de vuelta a 'b'
    while (*a)
    {
        pa(a, b);
    }
}
*************************************
void sort_stack_five_numbers(t_stack **stack_a, t_stack **stack_b)
{
    int i = 0;
    int min_pos;

    // Move two smallest elements from stack A to stack B
    while ((*stack_a)->len > 3)
    {
        min_pos = find_min_node_position(*stack_a);
        if (min_pos <= (*stack_a)->len / 2)
        {
            while (min_pos-- > 0)
                ra(stack_a);
        }
        else
        {
            min_pos = (*stack_a)->len - min_pos;
            while (min_pos-- > 0)
                rra(stack_a);
        }
        push_b(stack_a, stack_b);
    }

    // Sort remaining three elements in stack A
    sort_stack_three_numbers(*stack_a);

    // Push elements back from stack B to stack A
    while ((*stack_b)->len > 0)
        push_a(stack_b, stack_a);
}

=====================================
void sort_stack_four_numbers(t_stack *stack_a, t_stack *stack_b)
{
    int max_pos;
    int i;
    t_node *current;

    // Encuentra la posición del número máximo en stack_a
    max_pos = find_max_node_position(stack_a);
    current = stack_a->head;

    // Mueve el número máximo a stack_b
    for (i = 0; i < max_pos; i++)
        current = current->next;

    if (max_pos <= stack_a->len / 2)
    {
        while (max_pos-- > 0)
            ra(&stack_a);
    }
    else
    {
        max_pos = stack_a->len - max_pos;
        while (max_pos-- > 0)
            rra(&stack_a);
    }
    push_b(&stack_a, &stack_b);

    // Ordena los tres números restantes en stack_a
    sort_stack_three_numbers(stack_a);

    // Mueve el número de stack_b de vuelta a stack_a
    push_a(&stack_b, &stack_a);

    // Si el número movido de vuelta a stack_a no está en su posición correcta, rota
    if (stack_a->head->data > stack_a->head->next->data)
        ra(&stack_a);
}

int find_max_node_position(t_stack *stack)
{
    int max;
    int position = 0;
    int max_position = 0;
    t_node *current;

    if (stack == NULL || stack->head == NULL)
        return 0;  // Manejar casos de error de manera apropiada

    current = stack->head;
    max = current->data;

    while (current != NULL)
    {
        if (current->data > max)
        {
            max = current->data;
            max_position = position;
        }
        position++;
        current = current->next;
    }

    return max_position;
}





=///=/=////////////////////////////////
void	sort_stack_three_numbers(t_stack *stack_a)
{
	t_node	*f;
	t_node	*s;
	t_node	*t;

	f = stack_a->head;
	s = f->next;
	t = s->next;
	if (f->data > s->data && s->data > t->data) // 3 2 1
	{
		sa(stack_a);
		rra(&stack_a);
	}
	else if (f->data > s->data && f->data > t->data && s->data < t->data) // 3 1 2
		ra(&stack_a);
	else if (f->data > s->data && f->data < t->data) // 2 1 3
		sa(stack_a);
	else if (f->data < s->data && f->data < t->data && s->data > t->data) // 1 3 2
	{
		sa(stack_a);
		ra(&stack_a);
	}
	else if (f->data < s->data && f->data > t->data) // 2 3 1
		rra(&stack_a);
}

void	sort_stack_four_numbers(t_stack *stack_a, t_stack *stack_b)
{
	int		min_pos;

	min_pos = find_min_node_position(stack_a);
	if (min_pos <= stack_a->len / 2)
	{
		while (min_pos-- > 0)
			ra(&stack_a);
	}
	else
	{
		min_pos = stack_a->len - min_pos;
		while (min_pos-- > 0)
			rra(&stack_a);
	}
	push_b(&stack_a, &stack_b);
	sort_stack_three_numbers(stack_a);
	push_a(&stack_b, &stack_a);
}

void	sort_stack_five_numbers(t_stack *stack_a, t_stack *stack_b)
{
	int	min_pos;

	while (stack_a->len > 3)
	{
		min_pos = find_min_node_position(stack_a);
		if (min_pos <= stack_a->len / 2)
		{
			while (min_pos-- > 0)
				ra(&stack_a);
		}
		else
		{
			min_pos = stack_a->len - min_pos;
			while (min_pos-- > 0)
				rra(&stack_a);
		}
		push_b(&stack_a, &stack_b);
	}
	sort_stack_three_numbers(stack_a);
	while (stack_b->len > 0)
		push_a(&stack_b, &stack_a);
}

